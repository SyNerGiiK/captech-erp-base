import os
from app import models
from app.db import database
from sqlalchemy import select
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from fastapi import Depends, HTTPException, status
import os
from datetime import datetime, timedelta
from jose import jwt
from passlib.context import CryptContext

SECRET_KEY = os.getenv("SECRET_KEY", "dev_change_me")
ALGO = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 60 * 24 * 7

# why: bcrypt_sha256 Ã©vite la limite 72 octets; fallback bcrypt pour compat
_pwd = CryptContext(schemes=["bcrypt_sha256", "bcrypt"], deprecated="auto")

def get_password_hash(password: str) -> str:
    return _pwd.hash(password)

def verify_password(plain: str, hashed: str) -> bool:
    try:
        return _pwd.verify(plain, hashed)
    except ValueError:
        # why: Ã©viter un 500 si mot de passe >72 octets
        return False

def create_access_token(sub: str, company_id: int) -> str:
    exp = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    payload = {"sub": sub, "company_id": company_id, "exp": exp}
    return jwt.encode(payload, SECRET_KEY, algorithm=ALGO)
# Pourquoi: dépendance d'auth centralisée pour protéger les routes
_auth_scheme = HTTPBearer(auto_error=False)

async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(_auth_scheme)) -> dict:
    token = credentials.credentials if credentials else None
    if not token:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Not authenticated")
    secret = os.getenv("SECRET_KEY", "dev-insecure")
    try:
        payload = jwt.decode(token, secret, algorithms=["HS256"])
    except JWTError:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid token")

    sub = payload.get("sub")
    company_id = payload.get("company_id")
    if sub is None or company_id is None:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid token payload")

    utbl = models.User.__table__
    cond = (utbl.c.id == int(sub)) if str(sub).isdigit() else (utbl.c.email == str(sub))
    user = await database.fetch_one(select(utbl).where(cond))
    if not user or int(user["company_id"]) != int(company_id):
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="User mismatch")

    return {"id": int(user["id"]), "email": user["email"], "company_id": int(user["company_id"])}
