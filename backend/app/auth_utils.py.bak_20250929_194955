from __future__ import annotations

import os
from datetime import datetime, timedelta
from typing import Optional, Dict, Any

from passlib.context import CryptContext
from jose import jwt, JWTError

from fastapi import Depends, HTTPException
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy import select
from app.db import database
from app import models

# -------------------------------------------------
# Password hashing
# -------------------------------------------------
_pwd = CryptContext(schemes=["bcrypt"], deprecated="auto")

def get_password_hash(password: str) -> str:
    return _pwd.hash(password)

def verify_password(plain: str, hashed: str) -> bool:
    try:
        return _pwd.verify(plain, hashed)
    except Exception:
        return False

# -------------------------------------------------
# JWT helpers (access + signed short-lived tokens)
# -------------------------------------------------
SECRET = os.getenv("JWT_SECRET") or os.getenv("SECRET_KEY") or "dev_secret_change_me"
ALGO = "HS256"

def create_access_token(sub: str, company_id: int, ttl_seconds: int = 60*60*24) -> str:
    now = datetime.utcnow()
    payload = {"sub": sub, "company_id": int(company_id), "exp": now + timedelta(seconds=ttl_seconds)}
    return jwt.encode(payload, SECRET, algorithm=ALGO)

def create_signed_token(kind: str, data: Dict[str, Any], ttl_seconds: int = 900) -> str:
    now = datetime.utcnow()
    payload = {"kind": kind, "exp": now + timedelta(seconds=ttl_seconds), **data}
    return jwt.encode(payload, SECRET, algorithm=ALGO)

def verify_signed_token(token: str, kind: Optional[str] = None) -> Dict[str, Any]:
    try:
        payload = jwt.decode(token, SECRET, algorithms=[ALGO])
    except JWTError as e:
        raise ValueError(f"invalid token: {e}")
    if kind is not None and payload.get("kind") != kind:
        raise ValueError("invalid kind")
    return payload

# -------------------------------------------------
# Auth dependency used by routers
# Dev-friendly: if no Authorization header, fallback to first user in DB.
# Tests can still override Depends(get_current_user).
# -------------------------------------------------
_auth_scheme = HTTPBearer(auto_error=False)

async def get_current_user(
    credentials: Optional[HTTPAuthorizationCredentials] = Depends(_auth_scheme),
):
    # If you later want strict JWT, parse credentials and verify here.
    # For now, we keep the dev fallback so you can work without a token.
    utbl = models.User.__table__
    row = await database.fetch_one(select(utbl).limit(1))
    if not row:
        raise HTTPException(status_code=401, detail="Not authenticated")
    return {
        "id": int(row["id"]),
        "email": row.get("email"),
        "company_id": int(row["company_id"]),
    }
